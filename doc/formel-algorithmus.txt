-*- coding: utf-8; mode: text; mode: flyspell; mode: auto-fill -*-

Vorweg zu den Begrifflichkeiten: Explizite Klammerung funktioniert mit den
unescapierten geschweiften Klammern, implizite Klammerung mit allen anderen.

Alle Node-Elemente müssen eine reroot()-Methode bekommen, damit sie innerhalb
des Baumes verschoben werden können.  Das sollte auch über Bäume hinweg
funktionieren.


* parse_math_row
================

Die zentrale Funktion ist parse_math_row.  Sie scannt mathematisches Material
und gibt exakt ein Mathematik-Element (eventuell NoneNode), sowie die aktuelle
Parse-Position zurück.

Die Eingangsparameter sind: excerpt, position, group_type, current_sequence und
in_unit.

current_sequence ist dabei entweder "", "subscripts" oder "superscripts".  Es
bezeichnet die aktuelle Sub/Superskript-Sequenz, also ob es gerade „nach unten“
oder „nach oben“ geht.  In {1^2^3} ist die Sequenz beispielsweise durchgehend
"superscripts".  In {1₂_3} ist es durchgehende "subscripts".  Wenn nicht gerade
Sub/Superskripte geparst werden, ist dieser Parameter "" und ungenutzt.

group_type kann dabei folgende Werte annehmen:

• "explicit": die Gruppe wurde mit einer »{« geöffnet.  Terminierung also nur
  durch »}«, und das nächste zu parsende Zeichen ist das unmittelbar danach.

• "implicit": die Gruppe wurde mit einer »(«, »[«, »\{« etc. geöffnet.
  Terminierung durch schließende implizite Klammern exklusive »|« und »‖«, dann
  ist das nächste zu parsende Zeichen unmittelbar dahinter.  Oder durch eine
  schließende explizite Klammer, dann ist sie selbst das nächste zu parsende
  Zeichen.

• "|", "⟨", "‖": die Gruppe wurde mit eben jenem Zeichen eröffnet.
  Terminierung durch schließende implizite Klammern inklusive »|«, »|«,
  bzw.(sic!) »‖«, dann ist das nächste zu parsende Zeichen unmittelbar
  dahinter.  Oder durch eine schließende explizite Klammer, dann ist sie selbst
  das nächste zu parsende Zeichen.

• "explicit subscript", "explicit superscript", "implicit subscript", "implicit
  superscript", "topscript", "bottomscript": die Gruppe ist eines dieser Dinge.
  "_", "^" etc. sind nicht das erste Zeichen, das geparst wird (das wird schon
  vom Aufrufer übernommen), sondern das unmittelbar folgende.  Terminieren tun
  nicht-alphanumerische Zeichen sowie Zeichen aus dem falschen „Stockwerk“
  (z. B. bei "₂x" terminiert das "x").

  Ein "_" terminiert nur dann, wenn current_sequence="superscripts" ist.  Ein
  "^" terminiert nur dann, wenn current_sequence="subscripts" ist.  Ansonsten
  greift die Regel der Rechts-Assoziativität von Sub/Superskripten.

  Fängt das Skript sofort mit einer öffnenden Klammer an, wird damit natürlich
  math_parse_row nochmal aufgerufen, dann aber sofort abgebrochen.  Das zum
  Abbruch geführte Zeichen ist das nächste, was vom Aufrufer geparst wird.

• "operator-terminated": die Gruppe ist ein Radikand oder eine physikalische
  Einheit.  Terminierung durch alles, was nicht Buchstabe oder Ziffer ist (im
  weitesten Unicode-Sinne).  Insbesondere terminieren die
  Sub-/Superskript-Ziffern und -Minuszeichen _nicht_.  Das zum Abbruch geführte
  Zeichen ist das nächste, was vom Aufrufer geparst wird.

• "whitespace-terminated": die Gruppe ist ein Matrix-Element.  Terminierung
  durch Whitespace (0x9, 0x20, 0xa0, Zeilenumbruch) oder eine schließende
  Klammer.  Das zum Abbruch geführte Zeichen das nächste, was vom Aufrufer
  geparst wird.

parse_math_row wird praktisch die gesamte Arbeit machen.  Insbesondere wird die
MathGroup-Klasse keine parse-Methode brauchen.  Aber auch MathIdentifier,
MathText oder MathOperator werden in parse_math_row komplett gebaut.

Als erstes wird eine MathGroup gebaut, in deren Kinderliste alle eingeparsten
Element hinzugefügt werden, und die gleichzeitig als Mutter bei der Erzeugung
der Element und rekursiven Aufrufen von parse_math_row dient.

parse_math_row muß bei _jeder_ öffnenden Klammerung sich selbst rekursiv
aufrufen, bei impliziter Klammerung mit der Klammer als dem nächsten zu
parsenden Zeichen.  Im Falle von impliziter Klammerung _und_ wenn das erste
Element auch wirklich eine Klammer ist (kann im Nenner von Brüchen nämlich auch
nicht der Fall sein) setzt das neue parse_math_row ganz zu Beginn
opening_brace=True.

Wird eine passende schließende Klammer gefunden, wird im Falle einer impliziten
schließenden Klammer closing_brace=True gesetzt, diese Klammer zur MathGroup
hinzugefügt und als neue Parse-Position das Zeichen hinter dieser Klammer
angegeben.  Im Falle einer »}« hingegen gibt es zwei Möglichkeiten: Wurde die
aktuelle MathGroup auch explizit geöffnet, ist die neue Parse-Position das
Zeichen hinter der »}«.  Wurde sie implizit geöffnet, ist die neue
Parse-Position die »}«, weil sie auch von der aufrufenden parse_math_row
verarbeitet werden muß (eventuell sogar noch weiter durchgereicht werden muß).

Die Variable numerator_index gibt die Position des letzten Kindes der aktuellen
MathGroup an, an der ein Zähler beginnen würde, wenn ein Bruch gefunden würde.
Beginnt die Gruppe mit einer impliziten Klammer, ist diese Variable erstmal 1,
denn das nullte Element würde ja nicht zum Zähler des Bruchs dazugehören.  Bei
Interpunktion, menschlichem Text, Pfeilen und Relationszeichen wird der Wert
entsprechend auf die aktuelle Kinderlistenlänge + 1 erhöht.

in_unit=True bedeutet, daß zur Zeit eine physikalische Einheit geparst wird.
Das wird an Tochteraufrufe grundsätzlich durchgeschliffen.

in_denominator=True wird in parse_math_row selber gesetzt (wenn es zu
Optimierung führt), wenn der Elter eine MathFraction ist.  Es bedeutet, daß
gerade ein Nenner geparst wird.  Das bedeutet wiederum, daß zusätzlich zu den
anderen möglichen Abbruchstellen an den typischen Bruch-Terminierungen
(z. B. Vergleichsoperatoren) abgebrochen wird, und daß grundsätzlich das
Abbruch-provozierende Zeichen das nächste zu parsende ist.


*.* Der Central Loop
====================

Schritte in parse_math_row, während durch das Excerpt gewandert wird:

  1. Ist man Operator-terminiert und es wird nicht-alphanumerisches Material
     gefunden, bricht die Schleife ab.

  2. Wird eine öffnende Klammer gefunden, wird parse_math_row für das folgende
     erneut aufgerufen und das Ergebnis an die Kinderliste des Rückgabewertes
     angehängt.

  3. Wird ein Bruchstrich gefunden, werden die Kinder der aktuellen Gruppe ab
     numerator_index in eine eigene, neue Gruppe rerootet und die als Zähler
     einer neuen MathFraction hinzugefügt.  Die MathFraction wird in die
     aktuelle Gruppe eingehängt.  Dann wird parse_math_row zum Sammeln des
     Nenners aufgerufen, wobei group_type durchgeschliffen wird.

  4. Akzente: Zeichen mit diakritischen Zeichen müssen zerlegt werden, und
     folgende Combining Diacriticals zur Liste der Akzente hinzugefügt werden.
     Daraus wird dann ein MathAccent-Element gebaut.

     Sind nur Combining Diacriticals vorhanden, machen halt nur sie die Liste
     aus, und aus ihnen und dem zuletzt hinzugefügten Kind zur aktuellen
     MathGroup wird ein MathAccent gebaut (Reroot nötig).

  5. Skripte: Kritisch sind nur die Präskripte.  Werden sie gefunden, wird ein
     MathTensor angelegt, das abwechselnd die Sub- und Super-Präskripte als
     Kindelemente aufnimmt (können u. U. NoneNode sein).  Sobald die Basis
     bekannt ist, wird sie angehängt und ihr Index in einem Attribut von
     MathTensor gespeichert.  Dann werden Top- und Bottomskripte und die
     „normalen“ Sub/Superskripte eingeparst und angehängt.

     Das Parsen der Top- und Bottomskripte macht leider ein Reroot nötig.

  6. Matrizen, Vektoren und Wurzeln sind trivial, weil sie eine Präfix-Syntax
     haben.

parse_math_row achtet bei der Rückgabe eines Funktionswertes darauf, daß, wenn
die MathGroup leer geblieben ist, NoneNode zurückgegeben wird, im Falle von
einem Kind-Element eben dieses Element (Achtung, vorher Reroot nötig), und im
Falle von mehr Kind-Elementen die ganze MathGroup.


* Globale Konstanten
====================

Ich brauche ein Set mit sämtlichen öffnenden Unicode-Klammern (inklusive des
Pipe-Zeichens und des doppelten vertikalen Strichs), und eines mit sämtlichen
schließenden (ohne Pipe-Zeichen & Co). Außerdem benötige ich ein Dictionary,
das alle Unicode-Superskripte auf normale Zeichen abbildet, und noch eines, das
dasselbe mit Subskripten tut.

Ich brauche einen kompilierten regulären Ausdruck, der Zahlen parsen kann.
Wenn der Autor mit einer Direktiven von Dezimalpunkt auf Dezimalkomma wechselt,
muß diese Variable neu berechnet werden.

Außerdem brauche ich ein Set mit allen eingebauten Funktionen, und ein Set mit
allen eingebauten Multi-Zeichen-Bezeichnern (letztere werden zwar als
Multi-Zeichen-Bezeichner erkannt, aber nicht aufrecht gedruckt).  Beides sind
von Set abgeleitete Datentypen, die ein Attribut aktuell halten, welches einen
kompilierten regulären Ausdruck enthält von der Form
"Element1|Element2|Element3|…".

Ich brauche ein Set mit allen sog. „großen Operatoren“.  Horizontale Klammern
werden allerdings extra behandelt.

Ich brauche ein Set mit allen Vergleichsoperatoren.



 LocalWords:  coding utf mode text longlines parse math row scannt Elter True
 LocalWords:  whitespace terminated Sub enclose group has opening brace closing
 LocalWords:  False LocalWords frozenset Pipe mappt combined diacritical Marks
 LocalWords:  combining MathFraction MathIdentifier weitergeparst excerpt Loop
 LocalWords:  position NoneNode Klammerung explicit implicit Node reroot fill
 LocalWords:  Präskripte MathTensor Bottomskripte Diacriticals MathAccent auto
 LocalWords:  flyspell type sub superscript Präskript geparst top bottomscript
 LocalWords:  Bottomskript standalone sic radicand matrix element nominator
 LocalWords:  index nullte Relationszeichen Kinderlistenlänge rerootet unit
 LocalWords:  denominator numerator operator subscript topscript current
   LocalWords:  sequence subscripts superscripts
