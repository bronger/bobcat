-*- coding: utf-8; mode: longlines; ispell-local-dictionary: "british" -*-

== Sub- and superscripts (or indices and exponents) ==

Sub- and superscripts work a little bit differently in Bobcat than in LaTeX. First, they are terminated by whitespace rather than braces:

<code>
    Bobcat                  LaTeX
   ========                =======

    x_12 y                 x_{12}y
    x_12y                  x_{12y}
    x_{12}y                x_{12y}
    x_1{2}y                x_{12y}
</code>

Such constructs are called “atoms”.  In these examples, their ''base'' is “x”.  Atoms can also have prescripts and stacked material, see below.

Alternatively to whitespace, sub/superscripts are terminated by another sub/superscript and by closing braces of any kind:

<code>
    x_1^2                  x_1^2
    x_11^22                x_{11}^{22}
    x_1_2                  x_1{}_2
    (x_1)y                 (x_1)y
    |x_1|y                 |x_1|y
</code>


=== Tensors ===

The last line shows tensor notation.  This also allows for prescripts:

<code>
    _1^3_2^4 x_5^7_6^8     _1^3{}_2^4x_5^7{}_6^8
    ₁³₂⁴x₅⁷₆⁸              _1^3{}_2^4x_5^7{}_6^8
</code>

So the space after the “4” is necessary only if no sub/superscript unicode codepoints are used.  This leads in the print output to

<code>
                     ₃₄ ₇₈
                       x
                     ¹² ⁵⁶
</code>

But, if you want to write something like

<code>
                      ₃ ₄  ₇ ₈
                         x
                     ¹ ²  ⁵ ⁶
</code>

you have to input:

<code>
    _1_^3_2_^4 x_5_^7_6_^8        _1{}^3{}_2{}^4x_5{}^7{}_6{}^8
    ₁_³_₂_⁴x₅_⁷_₆_⁸               _1{}^3{}_2{}^4x_5{}^7{}_6{}^8
</code>

The upper notation shows how the inserting of »_« (»^« would have worked, too) breaks up the pairs of sub- and superscript, thus leaving an empty space. In the lower notation, »^« instead of »_« would have worked, too, because also here, it's just important to break up the pairs.

By the way, the ''ordering'' within a pair is insignificant.


== Stacked operators ==

With »__« and »^^«, one can create stacked material.  The “index” or “exponent” is printed in a smaller point size than the base by default (however, this may be decided upon by the backend on a per-case basis).  Additionally, horizontally stretchable single characters (in base or one argument) are stretched.

There must not be whitespace before »__« or »^^«.  Although it would be syntactically still unambiguous if there was (because we have no prescripts here), it would be too confusing, given the analogy to normal sub/superscripts.  If there is whitespace, it is ignored, with a parse warning being raised.

Sequenced »__« and »^^« are possible.  However, to a given base, you may only add at most ''one'' »^^« sequence and at most ''one'' »__« sequence.  The order of these two is not important (their inner order is, of course).  This can be used for <code lang="latex">\overbrace</code> and <code lang="latex">\underbrace</code> constructs.

<code>
    x =^^a>b 1             x \stackrel{a>b}{=} 1
    x =__a<b 0             x \stackrel[a>b]{}{=} 0  % with package "stackrel"
    A →^^"transform" B     A \xrightarrow{\mathrm{transform}} B
    {A+B}^^⏞^^"sum"        \overbrace{A+B}^{\mathrm{sum}}
</code>

If you want to use »__« and »^^« and sub/superscripts for the same base, »__« and »^^« must come after all sub/superscripts.  Sub/superscripts within or after the stacking refer to the stacked material itself.  In other words, stacked material can contain all top-level material which is allowed in sub/superscripts, ''plus'' sub/superscripts themselves.  “Top-level” in this context means that by using subgroups, arbitrary material is allowed in anyway.


== Whitespace ==

“Terminating whitespace” in this blueprint means the breaking or non-breaking space (0x20 and 0xa0), tabs, and line endings.  The reason why the non-breaking space is included is that it should be possible to group things in the formula so that the editor doesn't break it, however, it must still be possible to terminate exponents.

Terminating whitespace simply separates tokens and doesn't lead directly to spacing behaviour (except of course, that the tokens may also be separated by the output engine somehow).

Every non-breaking space (0xa0) which doesn't terminate something, and every non-breaking thin space may denote a physical quantity, see below.

=== Explicit spacing ===

Every escaped whitespace doesn't terminate anything but inserts explicit spacing at this position.  The same is true for all non-spaces (neither 0x20 nor 0xa0), including the non-breaking thin space if it cannot be interpreted as part of a physical quantity.

Subsequent explicit spacing simply accumulates, no matter how breaking or non-breaking whitespace is mixed.  It leads to explicit horizontal spacing in the output.  Note that there is also negative whitespace defined in Unicode.


== Roots ==

Roots start with »√« (and only this).  Their radicand is whitespace-terminated.  However, whitespace is allowed between the root symbol and the radicand for the sake of readability.  It is not allowed between the root symbol and an optional root exponent.

<code>
    √2π                    \sqrt{2\pi}
    √ 2π                   \sqrt{2\pi}
    √ {2 π}                \sqrt{2\pi}
    √^3 {2 π}              \sqrt[3]{2\pi}
    ³√ {2 π}               \sqrt[3]{2\pi}
    √³ {2 π}               \sqrt[3]{2\pi}
    ∛ 2π                   \sqrt[3]{2\pi}
    ³ √2π                  ^3\sqrt{2\pi}
</code>

As a special convenience, superscript Unicode codepoints are allowed immediately before the root symbol.


== Big operators ==

Sums, integrals, and the like work accordingly, i. e. their limits have exactly the same syntax as sub-/superscripts:

<code>
    ∑_i=0^n x_i            \sum_{i=0}^n x_i
    ∑_{i=0}^n x_i          \sum_{i=0}^n x_i
    ∑_i=0ⁿ x_i             \sum_{i=0}^n x_i
</code>

Note that Unicode distinguishes between \sum and \Sigma: ∑ and Σ.

You may use »__« and »^^« instead of »_« and »^«.  They have exactly the same semantics for big operators, however, for a given big operator, you must not mix both variants.  If you use »__« and »^^«, you can use sub/superscripts within their parameters, in accordance with ordinary stacking.

Multiple sub/superscripts accumulate:

<code>
 ∑__0≤i≤m_k__0<j<n P(i,j)    \sum_{\substack{0\le i\le m_k\\ 0<j<n}} P(i,j)
</code>

Note that subscripts pile up downwards but superscripts do it upwards.


== Mathematical accents ==

For mathematical accents, Bobcat uses the “combining diacritical marks” from Unicode.  In particular, this means that their use is ''postfix'' (in contrast to LaTeX's prefix notation).  For wide accents, you have to put the accent on the closing brace (which your editor may display as the accents being positioned after the brace):

<code>
              ẍ                       \ddot x
              ẍ̇                     \dot{\ddot x}
            {xyz}̃                 \widetilde{xyz}
</code>


=== The “prime” character ===

The prime character »′« seems to be a real issue because some people consider it in the exponent and some do not.

In LaTeX, it is given by <code lang="latex">\prime</code>, however, this is not in the exponent, so you must write <code lang="latex">$f^\prime(x)$</code>.  The same seems to be true for some screen fonts as well as for MathML 2.0.  See http://www.albany.edu/~hammond/gellmu/primeaccents2.xhtml for a more detailed discussion.

However, the Unicode specs say that it is already in the exponent, as well as its doubled etc. siblings.  So, Bobcat also treats it as being already in the exponent.  Like LaTeX, you may use the apostrophe »'« (and <code>''</code>, <code>'''</code> etc) as a convenient shortcut:

<code>
             f'                         f'
             f′                         f'
</code>


== Fractions ==

Fractions are in Bobcat more like TeX's rather than LaTeX's syntax but Bobcat uses // instead of <code>\over</code>.  One can also use Unicode codepoint 0x2215, or »∕«.  If the most inner braces/parentheses/brackets nest neatly, you don't even need the grouping braces:

<code>
    1 // 2               \frac{1}{2}
  2 + 3 // 2·4           \frac{2+3}{2\cdot 4}
   3 {1//2}              3\frac{1}{2}
  1 ∕ 2 ∕ 3              \frac{1}{\frac{2}{3}}
  4 + (2 ∕ 3)            4 + \left(\frac{2}{3}\right)
</code>

Note that in the last two examples, there are no slashes in the Bobcat code but codepoints 0x2215.  Your display program may render them indistinguishable, though.  An ordinary slash is just a slash in Bobcat.  Rationale for using // instead of just the slash: Division takes precedence over addition, so an author could think that <code>2 + 3 / 2</code> is rendered like <code lang="latex">2 + \frac{3}{2}</code>.

Alignment markers, relational operators, arrows, atoms with a relational operator or an arrow as their base, general punctuation (full stop, comma, semicolon, colon), and text insertions delimit a fraction.  If you want them as part of the fraction, enclose the (de)nominator in curly braces:

<code>
    1 // 2 = 0.5         \frac{1}{2} = 0.5
 1 // 2 =^^"!" 0.5       \frac{1}{2} \stackrel{\mathrm{!}}{=} 0.5
   1 // {2 ≠ 0.5}        \frac{1}{2 ≠ 0.5}
</code>


== Braces: stretchable and grouping ==

In Bobcat, all braces are stretchable by default, so LaTeX's <code lang="latex">\left</code> and <code lang="latex">\right</code> are not necessary.  If you want to have a brace non-stretched, put curly braces around it.

By the way, the curly braces themselves must be escaped with \ if you want to have them as-is, as in LaTeX.

All kinds of braces are grouping in Bobcat, not just { and }.  However, Bobcat considers an opening and a closing brace a pair, and nothing else.  So, "(…)" is a group, as is "[…)" or "\{…⟩".  But "(…" or "[…[" are not considered as groups, therefore, you must enclose them with curly braces to make the grouping explicit: "{(…}" and "{[…[}".  Un-escaped curly braces must always nest properly.

=== Special case: the vertical line ===

One special case are single or double vertical bars.  Although they open and close a group as all other delimiters, the exact “kind” must match for a closing.  So, "|…|" as well as "|…)" are groups, but "(…|" is not.  However, when parsing sub/superscripts (''not'' top/bottom scripts), single or double vertical bars behave like ''closing'' braces, i. e., they terminate the sub/superscript.

For a stretchable vertical bar in the sense of “such that”, one must use Unicode codepoint \0x2223 (DIVIDES), with an open \{ or ⟨ active.  It doesn't do any grouping.  Without an \{ or ⟨ as the currently open grouping, it means the binary operator „divides“, and doesn't stretch.

The pipe sign, when used with subscripts, is interpreted as a deep vertical bar with the meaning “at the location …” or “with constant …” (in e. g. thermodynamics).


== Text within a formula ==

Bobcat's counterpart of AMSMath's <code lang="latex">\text</code> is <code>"..."</code>.  This idea was taken from OpenOffice.org:

<code>
   m_"rest"              m_\mathrm{rest}
   a ", if " b>0       a \text{, if } b>0
</code>

In contrast to LaTeX, it is not possible in Bobcat to use arbitrary markup in such text insertions.  Apart from plain sequence of characters, it may contain only few elements, namely emphasis, cross referencing, citations, roles, and index entries.  The reason is that anything else cannot be translated to MathML (and is bad style anyway).

By the way, the above mathrm/text dichotomy is no error: On the top level, Bobcat will emit a <code lang="latex">\text</code> macro, however anywhere else, it will emit <code lang="latex">\mathrm</code> to prevent it from assuming the markup from the surrounding text (e.g. italics).


== Matrices and vectors ==

A matrix is given in Bobcat by

<code>
matrix:: 1   2   3   
         4   2   6   
         7   8   9  = …
</code>

So, not only whitespace but also linebreaks are significant here.  However, the horizontal alignment in the source code is not important.

You may give parameters to the matrix as a whole or to single cells in backquotes:

<code>
matrix:: `columns=lll` 1   2`c`   3   
                       4      2`span=2`   
                       7   8      9  = …
</code>

This means that all cells are left-aligned (default is centre), and that the second cell in the first row is centred.  You also see a column span. (Rowspans are not possible in matrices.)  Note that cell parameters must follow directly the cell contents without whitespace in between.  If a cell contains whitespace, enclose it in {…}.

If you dislike this line break thing, you can also give the size explicitly:

<code>
matrix:: `size=3x3` 1 2 3  4 2 6  7 8 9 = …
</code>

Instead of “x”, you can also use “×” or »;« to separate the number of rows from the number of columns.

By default, matrices are enclosed with (…).  With the parameters “braces”, “left brace”, and “right brace”, you can change that.


=== Vectors ===

Vectors are slightly different from matrices because autodetecting the size is not feasible:

<code>
vector:: 3, 1 2 3 = …
</code>

The size parameter is the first, comma-separated argument.


== Text blocks ==

Text blocks are entered as <code>`|name of text block|`</code>, so enclosed in backquotes and pipe signs.  This is a handy means to include subformulas:

<code>
{√ `|radicand|`}

|radicand|:: {2π}
</code>

They are inserted as a parsed subgroup, and not on the scanner-level.  If the textblock doesn't contain a formula but general inline material, it is implicitly surrounded by "…".


== Physical quantities ==

When the Bobcat parser encounters a non-breaking space of some kind, which doesn't just terminate the current formula element, it tries to parse the surrounding material as a physical quantity, which consists of a number (before the space) and/or a physical unit (after the space).

The number must have the typical format used in programming languages, e.g. <code>1.3e-4</code>.  You may use a decimal point or a decimal comma.

The unit is implicitly a formula (so even outside formulae, you needn't use curly braces), however, if it contains whitespace, you must enclose it with curly braces.  All consecutive Latin letters, as well as µ and Å (and maybe a few others) are interpreted as units, which means that they will be printed upright, among other things.

In the following examples, I use the ~ for the non-breaking space:

<code>
   2,34e16~           $2{,}34\cdot10^{16}$
     3~m              \unit[3]{m}
    ~m//s             $\mathrm{\frac{m}{s}}$
 {A = 3~cm²}          $A = 3\mathrm{cm^2}$
</code>

The backend or theme may render numbers differently.


== Alignment ==

Horizontal alignment over multiple displayed equations is done with the ampersand &.  The parts of the formula are aligned as AMSmath does it: Every »&« switches between right-aligned and left-aligned, and every even-numbered »&« (starting with 1) additionally adds stretchable space to set apart the next “equation column”.

There is one subtle difference though: All odd-numbered »&« centre the following ''group'' after them.  Like in AMSmath, these »&« are usually placed before relational operators.  However in AMSmath, these operators are neatly aligned only if they have the same width.  But if you write e.g. text on top of them, this is not the case anymore.  Bobcat, in contrast, centres the following group, so that it is easy to align operators (or other things) of different widths.

<code>
{8.44x + 55y  &= 0}
{3.1 x − 0.7y &= −1.1}
</code>

Within an equation, every sequence of math groups (enclosed with e. g. {…}) with »&« within them is printed on top of each other and aligned according to the ampersands.  The AMSmath environments “split” and “aligned” will be used for realising this in LaTeX.

Alignment doesn't survive across blocks.  So if you insert an empty line to an equation sequence, the following equations – as long as they form a block of their own – have other alignment points.


== Equation labelling and numbering ==

By default, Bobcat will produce numbering for all displayed equations.  This can be changed so that only equations with a label get a number.  Labels are given in backquotes behind the displayed equation:

<code>
{a² + b² = c²}   `pythagoras`
</code>


== Built-in functions ==

Functions such as sin or cos are recognised according to a built-in table.  If you want to write <code lang="latex">$sin$</code>(sic!), you must write <code>{si n}</code> or <code>{s in}</code> or <code>{s i n}</code> in Bobcat.  The author can add new built-ins with a directive:

<code>
add built-in functions:: glob, blob

{y = glob(x)}
</code>

An analogous directive will exist for multi-character identifiers (which will be printed in italics).


== The thing in action ==

So, one famous equation of special relativity is

<code lang="latex">
\frac{m_\mathrm{rest}}{\sqrt{1-\frac{v^2}{c^2}}}
</code>

in LaTeX and

<code>
m_"rest" // √ {1 − {v² // c²}}
</code>

in Bobcat.


 LocalWords:  sqrt xyz lang frac cdot mathrm wenn lll subformulas multi
 LocalWords:  pythagoras utf ispell british AMSmath xrightarrow
